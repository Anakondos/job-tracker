"""
Smart Form Filler - Fills forms using field database + AI fallback.

Flow:
1. Scan form ‚Üí detect all fields
2. Match each field to known field_type
3. Lookup answer in database
4. If not found:
   - YES/NO question ‚Üí ask user, save
   - SELECT ‚Üí show options, ask user, save  
   - TEXT (short) ‚Üí ask user, save
   - TEXT (long/JD-dependent) ‚Üí AI generates from CV+JD
5. Fill the field
6. Save new answers to database
"""

import json
import re
import time
from pathlib import Path
from typing import Optional, Dict, List, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum


# Paths
BROWSER_DIR = Path(__file__).parent
FIELD_DB_PATH = BROWSER_DIR / "field_database.json"
PROFILE_DIR = BROWSER_DIR / "profiles"


class FieldType(Enum):
    PROFILE = "profile"           # From user profile (name, email, etc)
    WORK_EXPERIENCE = "work_experience"  # Work history fields
    EDUCATION = "education"       # Education fields
    DEMOGRAPHIC = "demographic"   # Gender, race, veteran, disability
    YES_NO = "yes_no"             # Simple yes/no questions
    SELECT = "select"             # Dropdown with options
    TEXT_SHORT = "text_short"     # Short text answer
    TEXT_LONG = "text_long"       # Long text, may need AI
    UNKNOWN = "unknown"           # Not recognized


class AnswerSource(Enum):
    PROFILE = "profile"           # From profile.json
    DATABASE = "database"         # From field_database.json
    USER_INPUT = "user_input"     # Asked user during this session
    AI_GENERATED = "ai_generated" # Generated by AI
    DEFAULT = "default"           # Hardcoded default


@dataclass
class DetectedField:
    """A form field detected on the page."""
    selector: str                 # CSS selector to interact with field
    element_id: str               # HTML id attribute
    name: str                     # HTML name attribute
    label: str                    # Label text
    field_type: FieldType         # Classified type
    field_key: str                # Key in database (e.g., "work_authorization")
    html_type: str                # input/select/textarea
    input_type: str               # text/email/tel/checkbox/etc
    required: bool = False
    current_value: str = ""
    options: List[str] = field(default_factory=list)  # For dropdowns


@dataclass  
class FieldAnswer:
    """Answer for a field."""
    value: str
    source: AnswerSource
    jd_dependent: bool = False
    roles: List[str] = field(default_factory=lambda: ["*"])
    needs_confirmation: bool = False  # Ask user to confirm before using


class FieldDatabase:
    """Manages field patterns and answers."""
    
    def __init__(self, db_path: Path = FIELD_DB_PATH):
        self.db_path = db_path
        self.data = self._load()
        self.field_patterns = self.data.get("field_patterns", {})
        self.answers = self.data.get("answers", {})
        self.ai_cache = self.data.get("ai_generated_cache", {})
        self._pending_saves = []
    
    def _load(self) -> dict:
        """Load database from JSON."""
        if self.db_path.exists():
            with open(self.db_path, "r") as f:
                return json.load(f)
        return {"field_patterns": {}, "answers": {}, "ai_generated_cache": {}}
    
    def save(self):
        """Save database to JSON."""
        self.data["field_patterns"] = self.field_patterns
        self.data["answers"] = self.answers
        self.data["ai_generated_cache"] = self.ai_cache
        with open(self.db_path, "w") as f:
            json.dump(self.data, f, indent=2)
        print(f"üíæ Database saved to {self.db_path}")
    
    def match_field(self, detected: DetectedField) -> Tuple[str, FieldType]:
        """
        Match a detected field to a known field pattern.
        
        Returns:
            (field_key, field_type) or ("unknown", FieldType.UNKNOWN)
        """
        # Check by selector first (most reliable)
        for key, pattern in self.field_patterns.items():
            for selector in pattern.get("selectors", []):
                # Match exact or by ID
                if detected.selector == selector:
                    return key, FieldType(pattern.get("type", "unknown"))
                # Match ID without #
                if detected.element_id and selector == f"#{detected.element_id}":
                    return key, FieldType(pattern.get("type", "unknown"))
                # Match partial ID (e.g., #company-name-0 matches pattern #company-name-0)
                if detected.element_id and detected.element_id.startswith(selector.replace("#", "").rstrip("0123456789-")):
                    return key, FieldType(pattern.get("type", "unknown"))
        
        # Check by label text
        label_lower = detected.label.lower() if detected.label else ""
        for key, pattern in self.field_patterns.items():
            for label_pattern in pattern.get("labels", []):
                if label_pattern in label_lower:
                    return key, FieldType(pattern.get("type", "unknown"))
        
        return "unknown", FieldType.UNKNOWN
    
    def get_answer(self, field_key: str, field_type: FieldType, role: str = "TPM") -> Optional[FieldAnswer]:
        """Get answer for a field from database."""
        pattern = self.field_patterns.get(field_key, {})
        
        # Profile/Work/Education fields - get from profile
        if pattern.get("type") in ("profile", "work_experience", "education"):
            profile_key = pattern.get("profile_key")
            if profile_key:
                return FieldAnswer(
                    value=f"{{profile:{profile_key}}}",
                    source=AnswerSource.PROFILE,
                    jd_dependent=False
                )
        
        # Demographic fields - use default
        if pattern.get("type") == "demographic":
            default = pattern.get("default_answer")
            if default:
                return FieldAnswer(
                    value=default,
                    source=AnswerSource.DEFAULT,
                    jd_dependent=False
                )
        
        # Check answers database by type
        type_str = field_type.value
        answer_key = pattern.get("answer_key", field_key)
        
        if type_str in self.answers:
            answer_data = self.answers[type_str].get(answer_key)
            if answer_data:
                roles = answer_data.get("roles", ["*"])
                if "*" in roles or role in roles:
                    return FieldAnswer(
                        value=answer_data["answer"],
                        source=AnswerSource.DATABASE,
                        jd_dependent=answer_data.get("jd_dependent", False),
                        roles=roles
                    )
        
        # Check if needs AI
        if pattern.get("needs_ai"):
            return FieldAnswer(
                value="",
                source=AnswerSource.AI_GENERATED,
                jd_dependent=True,
                needs_confirmation=True
            )
        
        return None
    
    def save_answer(self, field_key: str, field_type: FieldType, answer: str, 
                    role: str = "TPM", jd_dependent: bool = False, source: str = "user"):
        """Save a new answer to database."""
        type_str = field_type.value
        
        if type_str not in self.answers:
            self.answers[type_str] = {}
        
        existing = self.answers[type_str].get(field_key, {})
        existing_roles = existing.get("roles", [])
        
        if role not in existing_roles and "*" not in existing_roles:
            existing_roles.append(role)
        
        self.answers[type_str][field_key] = {
            "answer": answer,
            "roles": existing_roles if existing_roles else [role],
            "jd_dependent": jd_dependent,
            "source": source
        }
        
        print(f"üìù Saved answer for '{field_key}': {answer[:50]}...")
        self._pending_saves.append(field_key)
    
    def add_field_pattern(self, field_key: str, label: str, field_type: str, 
                          selector: str = None):
        """Add a new field pattern (learned from form)."""
        if field_key not in self.field_patterns:
            self.field_patterns[field_key] = {
                "selectors": [],
                "labels": [],
                "type": field_type
            }
        
        pattern = self.field_patterns[field_key]
        
        if selector and selector not in pattern["selectors"]:
            pattern["selectors"].append(selector)
        
        label_lower = label.lower() if label else ""
        if label_lower and label_lower not in pattern["labels"]:
            pattern["labels"].append(label_lower)
        
        print(f"üìö Learned new pattern: {field_key} <- '{label}'")


class SmartFormFiller:
    """Intelligent form filler that uses database + AI."""
    
    def __init__(self, page, profile: dict, role: str = "TPM"):
        self.page = page
        self.profile = profile
        self.role = role
        self.db = FieldDatabase()
        self.detected_fields: List[DetectedField] = []
        self.filled_count = 0
        self.skipped_fields = []
        self.needs_user_input = []
        self.needs_ai = []
    
    def scan_form(self) -> List[DetectedField]:
        """Scan the page and detect all form fields."""
        print("\nüîç Scanning form fields...")
        
        fields = []
        elements = self.page.query_selector_all("input, select, textarea")
        
        for el in elements:
            try:
                el_id = el.get_attribute("id") or ""
                el_name = el.get_attribute("name") or ""
                el_type = el.get_attribute("type") or "text"
                tag = el.evaluate("el => el.tagName.toLowerCase()")
                required = el.get_attribute("required") is not None
                
                if el_type in ("hidden", "submit", "button", "file"):
                    continue
                
                # Find label
                label = ""
                if el_id:
                    label_el = self.page.query_selector(f"label[for='{el_id}']")
                    if label_el:
                        label = label_el.inner_text().strip()
                
                # Build selector
                if el_id:
                    selector = f"#{el_id}"
                elif el_name:
                    selector = f"[name='{el_name}']"
                else:
                    continue
                
                # Get current value
                current_value = ""
                try:
                    if tag == "select":
                        current_value = el.evaluate("el => el.options[el.selectedIndex]?.text || ''")
                    else:
                        current_value = el.input_value() or ""
                except:
                    pass
                
                # Get options for select
                options = []
                if tag == "select":
                    try:
                        options = el.evaluate("el => Array.from(el.options).map(o => o.text)")
                    except:
                        pass
                
                detected = DetectedField(
                    selector=selector,
                    element_id=el_id,
                    name=el_name,
                    label=label,
                    field_type=FieldType.UNKNOWN,
                    field_key="",
                    html_type=tag,
                    input_type=el_type,
                    required=required,
                    current_value=current_value,
                    options=options
                )
                
                # Match to known pattern
                field_key, field_type = self.db.match_field(detected)
                detected.field_key = field_key
                detected.field_type = field_type
                
                fields.append(detected)
                
            except Exception as e:
                continue
        
        self.detected_fields = fields
        print(f"   Found {len(fields)} fields")
        
        known = [f for f in fields if f.field_type != FieldType.UNKNOWN]
        unknown = [f for f in fields if f.field_type == FieldType.UNKNOWN]
        print(f"   ‚úÖ Known: {len(known)}")
        print(f"   ‚ùì Unknown: {len(unknown)}")
        
        return fields
    
    def _resolve_profile_value(self, placeholder: str) -> str:
        """
        Resolve a profile placeholder like {profile:personal.email}
        or {profile:work_experience.0.company}
        """
        if not placeholder.startswith("{profile:"):
            return placeholder
        
        key = placeholder.replace("{profile:", "").replace("}", "")
        parts = key.split(".")
        
        value = self.profile
        for part in parts:
            if value is None:
                return ""
            
            # Handle array index (e.g., "0" in work_experience.0.company)
            if part.isdigit():
                idx = int(part)
                if isinstance(value, list) and idx < len(value):
                    value = value[idx]
                else:
                    return ""
            elif isinstance(value, dict):
                value = value.get(part)
            else:
                return ""
        
        # Handle boolean
        if isinstance(value, bool):
            return "Yes" if value else "No"
        
        return str(value) if value else ""
    
    def _fill_field(self, field: DetectedField, value: str) -> bool:
        """Fill a single field with value."""
        try:
            el = self.page.query_selector(field.selector)
            if not el or not el.is_visible():
                return False
            
            el.scroll_into_view_if_needed()
            time.sleep(0.1)
            
            # Check if it's a Greenhouse-style autocomplete dropdown
            is_greenhouse_dropdown = (
                field.element_id and 
                any(x in field.element_id for x in ['gender', 'race', 'veteran', 'disability', 'hispanic', 'school', 'degree', 'discipline', 'country'])
            )
            
            if is_greenhouse_dropdown or field.html_type == "select":
                # Dropdown - click, type to filter, select
                el.click()
                time.sleep(0.3)
                # Type partial value to filter
                filter_text = value[:15] if len(value) > 15 else value
                el.type(filter_text, delay=30)
                time.sleep(0.4)
                self.page.keyboard.press("ArrowDown")
                time.sleep(0.1)
                self.page.keyboard.press("Enter")
                time.sleep(0.2)
            elif field.input_type == "checkbox":
                # Checkbox - click to toggle
                if value.lower() in ("yes", "true", "1"):
                    el.click()
            else:
                # Regular text input
                el.fill(value)
            
            return True
            
        except Exception as e:
            print(f"   ‚ùå Error filling {field.selector}: {e}")
            return False
    
    def fill_known_fields(self) -> int:
        """Fill all fields that have known answers."""
        print("\nüìù Filling known fields...")
        
        filled = 0
        
        for field in self.detected_fields:
            # Skip unknown fields
            if field.field_type == FieldType.UNKNOWN:
                self.skipped_fields.append(field)
                continue
            
            # Skip already filled
            if field.current_value and field.current_value not in ("Select...", "", "Select"):
                print(f"   ‚è≠Ô∏è  {field.field_key}: already filled ({field.current_value[:20]})")
                continue
            
            # Get answer from database
            answer = self.db.get_answer(field.field_key, field.field_type, self.role)
            
            if not answer:
                self.needs_user_input.append(field)
                continue
            
            # Resolve value
            value = answer.value
            if answer.source == AnswerSource.PROFILE:
                value = self._resolve_profile_value(value)
            
            if answer.source == AnswerSource.AI_GENERATED and not value:
                self.needs_ai.append(field)
                continue
            
            if not value:
                # Profile value not found
                self.needs_user_input.append(field)
                continue
            
            # Fill the field
            if self._fill_field(field, value):
                filled += 1
                display_value = value[:30] + ('...' if len(value) > 30 else '')
                print(f"   ‚úÖ {field.field_key}: {display_value}")
            else:
                self.skipped_fields.append(field)
        
        self.filled_count = filled
        return filled
    
    def process_unknown_fields(self, interactive: bool = True) -> List[dict]:
        """Process fields that need user input."""
        print(f"\n‚ùì Processing {len(self.needs_user_input)} fields needing input...")
        
        still_unknown = []
        
        for field in self.needs_user_input:
            print(f"\n   Field: {field.label or field.name or field.selector}")
            print(f"   Type: {field.html_type}, Input: {field.input_type}")
            if field.options:
                print(f"   Options: {field.options[:5]}{'...' if len(field.options) > 5 else ''}")
            
            if not interactive:
                still_unknown.append({
                    "selector": field.selector,
                    "label": field.label,
                    "type": field.html_type,
                    "options": field.options
                })
                continue
            
            label_lower = (field.label or "").lower()
            
            # Determine question type
            is_yes_no = any(kw in label_lower for kw in [
                "are you", "do you", "have you", "can you", "will you",
                "is your", "did you", "would you", "confirm"
            ])
            
            if is_yes_no or field.input_type == "checkbox":
                print(f"\n   ü§î Yes/No: {field.label}")
                answer = input("   (y)es / (n)o / (s)kip: ").strip().lower()
                
                if answer in ("y", "yes"):
                    value = "Yes"
                elif answer in ("n", "no"):
                    value = "No"
                else:
                    still_unknown.append({"selector": field.selector, "label": field.label})
                    continue
                
                if self._fill_field(field, value):
                    self.filled_count += 1
                    field_key = self._generate_field_key(field.label)
                    self.db.add_field_pattern(field_key, field.label, "yes_no", field.selector)
                    self.db.save_answer(field_key, FieldType.YES_NO, value, self.role)
                    
            elif field.options:
                print(f"\n   üìã Select:")
                for i, opt in enumerate(field.options[:15]):
                    print(f"      {i+1}. {opt}")
                if len(field.options) > 15:
                    print(f"      ... and {len(field.options) - 15} more")
                
                choice = input("   Enter number or (s)kip: ").strip()
                
                if choice.isdigit() and 0 < int(choice) <= len(field.options):
                    value = field.options[int(choice) - 1]
                    if self._fill_field(field, value):
                        self.filled_count += 1
                        field_key = self._generate_field_key(field.label)
                        self.db.add_field_pattern(field_key, field.label, "select", field.selector)
                        self.db.save_answer(field_key, FieldType.SELECT, value, self.role)
                else:
                    still_unknown.append({"selector": field.selector, "label": field.label})
                    
            else:
                print(f"\n   ‚úèÔ∏è  Text: {field.label}")
                
                # Check if long-form answer needed
                is_long = any(kw in label_lower for kw in [
                    "why", "describe", "tell us", "explain", "cover letter", "additional"
                ])
                
                if is_long:
                    print("   (Looks like a long answer - might need AI)")
                    jd_dep = input("   Is this JD-dependent? (y/n): ").strip().lower() == "y"
                    if jd_dep:
                        self.needs_ai.append(field)
                        continue
                
                value = input("   Enter value or (s)kip: ").strip()
                
                if value and value.lower() != "s":
                    if self._fill_field(field, value):
                        self.filled_count += 1
                        field_key = self._generate_field_key(field.label)
                        self.db.add_field_pattern(field_key, field.label, "text_short", field.selector)
                        self.db.save_answer(field_key, FieldType.TEXT_SHORT, value, self.role)
                else:
                    still_unknown.append({"selector": field.selector, "label": field.label})
        
        return still_unknown
    
    def _generate_field_key(self, label: str) -> str:
        """Generate a field key from label text."""
        if not label:
            return "unknown_field"
        key = re.sub(r'[^a-z0-9\s]', '', label.lower())
        key = re.sub(r'\s+', '_', key.strip())
        return key[:50]
    
    def get_summary(self) -> dict:
        """Get summary of form filling results."""
        return {
            "total_fields": len(self.detected_fields),
            "filled": self.filled_count,
            "skipped": len(self.skipped_fields),
            "needs_user_input": len(self.needs_user_input),
            "needs_ai": len(self.needs_ai),
            "unknown_fields": [
                {"label": f.label, "selector": f.selector} 
                for f in self.skipped_fields[:10]
            ]
        }
    
    def save_database(self):
        """Save any pending changes to database."""
        if self.db._pending_saves:
            self.db.save()
            print(f"üíæ Saved {len(self.db._pending_saves)} new answers to database")


def fill_form_smart(page, profile: dict, role: str = "TPM", interactive: bool = False) -> dict:
    """Fill a form using smart detection and database."""
    filler = SmartFormFiller(page, profile, role)
    filler.scan_form()
    filler.fill_known_fields()
    
    if interactive and filler.needs_user_input:
        filler.process_unknown_fields(interactive=True)
    
    filler.save_database()
    return filler.get_summary()
